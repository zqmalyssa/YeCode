package com.qiming.algorithm.leetcode;

/**
 * 整数替换
 *
 * 给定一个正整数 n，你可以做如下操作：1. 如果 n 是偶数，则用 n / 2替换 n。 2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。 n 变为 1 所需的最小替换次数是多少？
 *
 * 示例 1: 输入: 8  输出: 3  解释: 8 -> 4 -> 2 -> 1  示例 2: 输入: 7  输出: 4  解释: 7 -> 8 -> 4 -> 2 -> 1 或 7 -> 6 -> 3 -> 2 -> 1
 *
 * 思路：递归可以解，比较快的方法是位运算。当 n 为偶数时，不用犹豫，直接自除 2 即可。当 n 为奇数时，选择对 n 进行 +1 还是 -1 取决于哪一种运算能够带来更多的 **相连最低位的二进制 0 **，
 * 因为二进制最低位为 0，该数一定是偶数，是偶数则直接自除 2（即右移 1 位），相连的最低位的二进制 0 越多，代表右移的机会将会变多，n 也容易接近目标 1。奇数有两种情况：0bxx01 和 0bxx11，
 * 前者更适合做 -1 运算，因为 n 进行- 1 之后，二进制会比 +1 运算多一个 0； 后者(3 除外)更适合 +1 运算，因为 +1 会使两个二进制 1 都变成 0。以 0bxx11 结尾的数还有特殊的 3，特殊在 3+1=4(0bxx100)，
 * 比运算 -1 要多右移两次。
 *
 *
 */
public class IntegerReplacement {

  public int integerReplacement(int n) {
    int step = 0; //记录步数
    while (n != 1) {
      //偶数
      if ((n & 1) == 0) {
        n >>>= 1;
        step++;
      } else {
        //奇数
        n += ((n & 2) == 0 || n ==3) ? -1 : 1;
        step++;
      }
    }
    return step;

//    return f(n);

  }

  private int f(int n) {
    if (n == 1) {
      return 0;
    }
    if (n % 2 == 0) {
      // >>> 是无符号右移，二进制右移补零操作符，左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充，如value >>> num中，num指定要移位值value 移动的位数
      return f(n >>> 1) + 1;
    } else {
      return Math.min(f(n-1), f(n+1)) + 1;
    }
  }

}
